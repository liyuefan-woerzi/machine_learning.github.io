# CS82 Introduction to Machine Learning
## Week 8 - Neural Networks
___

## Contents:
* Biologically Inspired Systems
* Perceptron
* Activation Function
* Backpropagation
* XOR Gate

### Biologically Inspired Model



![](../image/1*Mz0a4EEsdJYsbvf5M_u-Sw.png)

The structure of a neuron within our brain was used to model an artificial neuron created in programming. A biological neuron has inputs and outputs. Dendrites are used to accept electrical signal as inputs and axons are used to connect to other neurons and pass on the signal. The "brain" of a neuron is in the nucleus that decides if it will fire based on the input it receives. Our brain has billions of those neurons connected with each other. 

The current understanding of the human biology is constantly changing. The above is an oversimplification.

### Mathematical Model of a Neuron

Inspired by the biological architecture of a neuron we create a mathematical model that is capable of similar computations as a neuron is. **However** this mathematical model is an oversimplification of what is actually happening in our brains. We call this model a **perceptron**. 

![](https://cdn-images-1.medium.com/max/1200/1*Yf6BWJq0kdHTumErO99bUQ.jpeg)



* Each neuron accepts a set of inputs $\textbf{X}=[x_0 \ldots x_n]$

* Each neuron produces a single output $f(\textbf{X}\times W +b)$. 
  *  $f$  is the **activation** function. 

  * $W=[w_0 \ldots w_n]$ are the **weights** of the neuron. It is an array the same size as $\textbf{X}$ . 
  * $b$ is the **bias** term. 

To calculate the output of a single neuron we need to calculate the **dot product** between $W$ and $\textbf{X}$ and add the bias term to that. We then pass the result as input to our activation function. 

**Looks familiar?** Very similar to a linear regression? $y=x_0\times m_0 + \ldots + x_n \times m_n + b$ 

Maybe even more similar to a **Logistic Regression**: $f(x_0\times m_0 + \ldots + x_n \times m_n + b)$

The activation function can be any function we decide, in some cases even the **sigmoid** function used by a Logistic Regression. Some activation functions include

```python
import numpy as np
import random
import matplotlib.pyplot as plt

# Single Neuron Model 
# attributes
X=np.random.random(10)
# trainable weights/parameters
W=np.random.uniform(size=10,low=-1,high=1)

# f(x)
y=np.dot(X,W)+random.random()

# sigmoid function
def sigmoid(y):
    return 1/(1+np.exp(-y))
  
# Making a prediction
print(sigmoid(y))	
```

> 0.23

Instead of a sigmoid function we can use many other alternatives. The main consideration on picking those functions depend on the problem we are trying to solve as well as draw-backs with each approach and possible ranges they take.

**Linear** $f(x)=x$

```python
import matplotlib.pyplot as plt
%matplotlib inline

def linear(y):
    return y
  
x=np.linspace(-10,10)
y=linear(x)
plt.title("Linear Function")
plt.plot(x,y)

```

![](data:image/png;base64,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)



Takes a range from $(-\infin,\infin)$

**Sigmoid** $f(x)=\frac{1}{1+e^{-z}}$ 

```python
import matplotlib.pyplot as plt
%matplotlib inline

def sigmoid(y):
    return 1/(1+np.exp(-y))
x=np.linspace(-10,10)
y=sigmoid(x)
plt.title("Sigmoid Function")
plt.plot(x,y)

```

![](data:image/png;base64,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)

Takes a range $(0,1)$

**RELU** $f(x)=max(0,x)$

```python
import matplotlib.pyplot as plt
%matplotlib inline

def relu(y):
    return y*(y>0)
x=np.linspace(-10,10)
y=relu(x)
plt.title("Relu Function")
plt.plot(x,y)


```

![](data:image/png;base64,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)

Takes a range $[0,\infin)$

**Tanh** $f(x)=tanh(x)$

```python
import matplotlib.pyplot as plt
%matplotlib inline

def tanh(y):
    return np.tanh(y)
x=np.linspace(-10,10)
y=tanh(x)
plt.title("Tanh Function")
plt.plot(x,y)

```

![](data:image/png;base64,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)

Takes a range $[-1,1]$

### Training a Perceptron

The goal when training a perceptron is to learn the weights as to minimize the error. 

The error is calculated by the loss function. For neurons that output real values (regression) we want to use a **linear** activation function because the prediction output can be anywhere in the range from $-\infin$ to $\infin$. We also have to use as a loss function **MSE** because it can calculate the error between our prediction.

For classification tasks, depending on the task at hand we can use **softmax** as an activation function and **categorical cross-entropy** for our loss . 

The value of the loss function is used to determine by what value to update the weights of a neuron and the bias. The weights and the bias are our trainable parameters. 

There are few techniques in updating the weights. Our goal during training is to minimize the loss, the greater the loss it is intuitive to make bigger changes to the values of the weights. However there can be some concerns.

* What exact value do I assign to the new weights? 
* How can this value be relative to the size of the error and know that it will reduce the loss? 
* What happens if one single data point in our dataset is mislabeled and then completely ruins our weights after an update?

There are so many questions and problems in deciding **how** to update the weights. There is no **perfect** way but there are **better** ways to update. 

An **optimizer**, tries to optimize the **loss function**, the goal of an optimizer is to reduce the value of the loss function (Cross-entropy or MSE) as close to zero as possible. 

Examples of **update rules**:

* $W=W_{before} + x$

* $W=W_{before}+\text{learning_rate}\times error \times x$

* **Learning Rate** is how much we want to consider each training example in updating the new weights for this update rule. There are update rules that decide the learning rate automatically, other rules that we only decide the starting learning rate and they adapt it. **This is the most important parameter in training and we will explain why in the next class.**

**Note** 

The update rule does **NOT** affect the accuracy of our **METHOD**  only the accuracy of our **MODEL**. What that is meant to say is that if there is no correlation in the data, if the algorithm/model you are using to classify the data is not suitable, no matter what update rule you use, you will not get good results. 

The update rule can affect the **SPEED** by which we learn the correct parameters for our model.

A bad update rule could take years to reach the minimum value the loss function can have while a good update rule can achieve the same in much less time, such as seconds. Hence to us the first update rule will never train our model because we are not willing to sit and wait for years for our model to train.

### MultiLayer Perceptron 

Having a single neuron doesn't add a lot of value since it is a linear regression or logistic regression model. The real advantage of perceptrons is when they are stacked together to form multiple layers. 

### XOR Problem

Remember Linear Classifiers. They are only able to find linear decision boundaries. Let's take as a simple example the XOR gate / dataset. This is exclusive OR, which means that it is true when only one of the inputs is true. It is a very simple problem but no linear classifier can correctly classify the inputs.

| Input 1 | input 2 | Output |
| ------- | ------- | ------ |
| 1       | 0       | 1      |
| 0       | 1       | 1      |
| 1       | 1       | 0      |
| 0       | 0       | 0      |

Visually

![img](../image/0_qdRb80zUpJPtrbRD_.gif)

Green is one class and red is another class. We use red for `0` or `False`  and green for `1` or `True`. We can't draw a single line to separate the two classes. In cases that our data is not linearly seperable a single perceptron will be unable to find a decision boundary

One way is to build a kernel on the data, but this is not always possible. A more **robust** way is to use multiple perceptrons to generate multiple boundaries. A logistic regression does very poorly on this artificial dataset. 

```python
from sklearn.linear_model import LogisticRegression
import pandas as pd
arr=[]
for i in range(0,2):
    for j in range(0,2):
        arr.append([i,j,int(bool(i) ^ bool(j))])
df=pd.DataFrame(arr, columns=["x1","x2","y"])
display(df)
clf = LogisticRegression().fit(df[["x1","x2"]], df["y"])
clf.score(df[["x1","x2"]], df["y"])		
```

> 0.5 

![image-20190726085610358](../image/image-20190726085610358.png)



A **XOR** can be calculated using the following logic  $x_1 \textbf{ xor } x_2 = \textbf{not} (x_1 \textbf{and }x_2) \textbf{ and } (x_1 \textbf{ or } x_2)$

```python
def xor(x1,x2):
  return not((x1 and x2)) and (x1 or x2)
for x1 in [False,True]:
 for x2 in [False,True]:
     print("x1: %s\t x2: %s\t x1 xor x2: %s"%(x1,x2,xor(x1,x2)))
```

>x1: False	 x2: False	 x1 xor x2: False
>x1: False	 x2: True	 x1 xor x2: True
>x1: True	 x2: False	 x1 xor x2: True
>x1: True	 x2: True	 x1 xor x2: False



![img](../image/1_Rm1Cd2KDoi1ACE-5KFP_Iw.png)

### Building a Multilayer Perceptron 

We can build a Multilayer Perceptron (**MLP**) by taking as input the features $x_1$ and $x_2$ and use **AND** gates **OR** gates and **NOT** gates to create an **XOR** gate. 

We can start by constructing an artificial dataset of 100 repeated XOR tables. This is so that we can give enough samples to our perceptron to learn the relationships.

```python
import numpy as np

def xor(x1,x2):
  x1=bool(x1)
  x2=bool(x2)
  #convert it to int to be able to use it with traditional models from sklearn
  return int(not((x1 and x2)) and (x1 or x2))

arr=[]
for _ in range(0,100):
  for x1 in [0,1]:
    for x2 in [1,0]:
      arr.append([x1,x2,xor(x1,x2)])
xor_data=np.array(arr)
print(xor_data)
X=xor_data[:,:2]
y=xor_data[:,2]
```

> [[0 0 0]
>  [0 1 1]
>  [1 0 1]
>  ...
>  [0 1 1]
>  [1 0 1]
>  [1 1 0]]

#### XOR GATE attempt

We use a linear solver with a simple logistic regression model to learn the XOR Gate

```python
from sklearn.linear_model import LogisticRegression
clf = LogisticRegression(solver="liblinear").fit(X, y)
clf.score(X, y)
```

> 0.5

Not a great score, same as random

### AND GATE

We first create the and gate dataset

```python
import numpy as np

def and_gate(x1,x2):
  x1=bool(x1)
  x2=bool(x2)
  #convert it to int to be able to use it with traditional models from sklearn
  return int(x1 and x2)

y_and=[]
for row in X:
	y_and.append(and_gate(row[0],row[1]))
y_and=np.array(y_and)
print(y_and)

and_clf = LogisticRegression(solver="liblinear").fit(X, y_and)
and_clf.score(X, y_and)
```

> 1.0

### Plot

```python
import matplotlib.pyplot as plt
%matplotlib inline

w=and_clf.coef_[0]
bias=and_clf.intercept_
x=np.linspace(0.2,1.2)
y_plot=-(bias+w[0]*x)/w[1]
plt.plot(x,y_plot,c='r')

# we only need to plot 4 first points
# plot x_1 (0 index) and x_2 (1 index) for the first 4 points
plt.scatter(x=X[:4,0],y=X[:4,1],c=['g' if bool(v) else 'r' for v in y_and[:4]],s=10)
plt.title("Decision Boundary AND GATE")
```

![image-20190726094014458](../image/image-20190726094014458.png)

### OR GATE 

```python
import numpy as np

def or_gate(x1,x2):
  x1=bool(x1)
  x2=bool(x2)
  #convert it to int to be able to use it with traditional models from sklearn
  return int(x1 or x2)

y_or=[]
for row in X:
	y_or.append(or_gate(row[0],row[1]))
y_or=np.array(y_or)
print(y_or)

or_clf = LogisticRegression(solver="liblinear").fit(X, y_or)
or_clf.score(X, y_or)
```

> 1.0

### Plot

```python
import matplotlib.pyplot as plt
%matplotlib inline

w=or_clf.coef_[0]
bias=or_clf.intercept_
x=np.linspace(0.2,1.2)
y_plot=-(bias+w[0]*x)/w[1]
plt.plot(x,y_plot,c='r')

# we only need to plot 4 first points
# plot x_1 (0 index) and x_2 (1 index) for the first 4 points
plt.scatter(x=X[:4,0],y=X[:4,1],c=['g' if bool(v) else 'r' for v in y_or[:4]],s=10)
plt.title("Decision Boundary OR GATE")

```

![image-20190726093947315](../image/image-20190726093947315.png)

### NOT GATE

```python
import numpy as np

def not_gate(x):
  #convert it to int to be able to use it with traditional models from sklearn
  return int( not bool(x))

y_not=[]
for row in X:
	y_not.append(not_gate(row[0]))
y_not=np.array(y_not)
print(y_not)

not_clf = LogisticRegression(solver="liblinear").fit(X[:,0].reshape(-1,1), y_not)
not_clf.score(X[:,0].reshape(-1,1), y_not)
```

### Plot

```python
import matplotlib.pyplot as plt
%matplotlib inline

w=not_clf.coef_[0]
bias=not_clf.intercept_
x=np.linspace(0.2,0.8)
y_plot=(bias+w[0]*x)
plt.plot(x,y_plot,c='r')

# we only need to plot 2 first points
plt.scatter(x=[0,1],y=[0,0],c=['r','g'],s=10)
plt.title("Decision Boundary NOT GATE")


```

![image-20190726110536906](../image/image-20190726110536906.png)

### XOR - Putting the pieces together

$x_1 \textbf{ xor } x_2 = \textbf{not} (x_1 \textbf{and }x_2) \textbf{ and } (x_1 \textbf{ or } x_2)$

```python
import numpy as np

X=[]
y=[]
for _ in range(0,100):
    for i in [0,1]:
        for j in [0,1]:
            X.append([i,j])
            y.append(xor(i,j))
X=np.array(X)
y=np.array(y)
```

![1553457884717](../image/1553457884717.png)

```python
x1_and_x2=and_clf.predict(X)
x1_or_x2=or_clf.predict(X)
not_x1_and_x2=not_clf.predict(x1_and_x2.reshape(-1,1))
not_and_or_x1_x2=np.array(list(zip(not_x1_and_x2,x1_or_x2)))
x1_xor_x2=and_clf.predict(not_and_or_x1_x2).reshape(-1,1)

from sklearn.metrics import accuracy_score
accuracy_score(x1_xor_x2, y)
```

> 1.0 

We could then define a xor classifier as a function composed of multiple models

```python
def xor_classifier(X):
  x1_and_x2=and_clf.predict(X)
  x1_or_x2=or_clf.predict(X)
  not_x1_and_x2=not_clf.predict(x1_and_x2.reshape(-1,1))
  not_and_or_x1_x2=np.array(list(zip(not_x1_and_x2,x1_or_x2)))
  x1_xor_x2=and_clf.predict(not_and_or_x1_x2).reshape(-1,1)
  return x1_xor_x2

xor_classifier([[0,1],[0,0],[1,0]])
```

>array([[1],
>       [0],
>       [1]])

## Plot

```python
import matplotlib.pyplot as plt
%matplotlib inline

# OR GATE
w=or_clf.coef_[0]
bias=or_clf.intercept_
x=np.linspace(-0.2,0.8)
y_plot=-(bias+w[0]*x)/w[1]
or_gate,=plt.plot(x,y_plot,'y',label='OR Boundary')



## NOT AND GATE
w=and_clf.coef_[0]
bias=and_clf.intercept_
x=np.linspace(0.3,1.2)
y_plot=-(bias+w[0]*x)/w[1]
not_gate,=plt.plot(x,y_plot,'r',label='NOT AND Boundary')




plt.scatter(x=X[:4,0],y=X[:4,1],c=['g' if bool(v) else 'r' for v in y[:4]],s=10)
plt.title("Decision Boundary XOR GATE")
plt.legend([not_gate, or_gate])
plt.show()
```

![image-20190726112340104](../image/image-20190726112340104.png)

The `NOT AND Boundary` will classify anything above that line as `True`

The `OR Boundary` will classify anything below that line as `True`. 

The final outcome of the classification is the combination of the two that, both of those must classify as `True`, hence is only the area between the two lines. 

### MLP Classifier

SKLearn provides a package with which you can define an MLPCLassifier and with many more perceptrons and layers and specific activation functions.

```python
from sklearn.neural_network import MLPClassifier
clf = MLPClassifier()
clf.fit(X,y)
clf.score(X,y)
```

>  1.0

We can also specify how many perceptrons we want as well as the optimization algorithm or **solver**. 

```python
# SGD is the optimizer used in this model
clf = MLPClassifier(solver='sgd',hidden_layer_sizes=(1))
clf.fit(X,y)
clf.score(X,y)
```

> 0.5

A single perceptron doesn't do too well in classifying an XOR relationship.

If we add multiple layers we can guarantee that our perceptron will learn to classify the XOR Relationship by learning the AND, OR and NOT relationships individually.

```python
# Adam is the most widely used solver
# We often want to limit the maximum iterations to avoid running for too long at the risk
# of not training enough
clf = MLPClassifier(solver='adam',max_iter=100000,hidden_layer_sizes=(10,10,10,5), random_state=0)
clf.fit(X,y)
clf.score(X,y)
```

> 1.0

The result of multiple layers together is a neural network. 

![]()

![Image result for neural network](../image/artificial_neural_network_1-791x388.jpg)

### MLPRegressor

Similarly for a regression problem we can define an MLPRegressor

```python
from sklearn.neural_network import MLPRegressor
clf=MLPRegressor()
```

[MLPRegressor Documentation](https://scikit-learn.org/stable/modules/generated/sklearn.neural_network.MLPRegressor.html#sklearn.neural_network.MLPRegressor)

### Beyond SKLearn

SKLearn takes care of the correct loss function and output layer activation function for us. It is a very simplified API that doesn't explore the whole potential of the Neural Networks. CS84 goes a lot more in detail in using Neural Networks for more advanced problems.

### Tensorflow Playground

[Tensorflow Playground](https://playground.tensorflow.org/#activation=tanh&batchSize=10&dataset=xor&regDataset=reg-plane&learningRate=0.03&regularizationRate=0&noise=0&networkShape=4,4&seed=0.00966&showTestData=false&discretize=false&percTrainData=50&x=true&y=true&xTimesY=false&xSquared=false&ySquared=false&cosX=false&sinX=false&cosY=false&sinY=false&collectStats=false&problem=classification&initZero=false&hideText=false)

![1553460045273](image/1553460045273.png)



```python
from sklearn.model_selection import train_test_split

clf = MLPClassifier(solver='adam',max_iter=500,hidden_layer_sizes=(10,10,10,5))
X_train, X_test, y_train, y_test = train_test_split(digits.data,digits.target,test_size=0.33)
clf.fit(X_train,y_train)
clf.score(X_test,y_test)
```

There are many parameters we can tune in order to get the best accuracy for our classifier

```python
from sklearn.model_selection import train_test_split

clf = MLPClassifier(solver='lbfgs',max_iter=500,hidden_layer_sizes=(10,10,10,5))
X_train, X_test, y_train, y_test = train_test_split(digits.data,digits.target,test_size=0.33)
clf.fit(X_train,y_train,verbose=True)
clf.score(X_test,y_test)
```

Increasing a parameters doesn't guarantee better results. There are problems of **overfitting**, **underfitting** and more other that we will discuss next class.